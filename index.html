<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Stork Galaxy Shooter - Multiplayer</title>
<style>
  :root{ --bg:#050816; --panel:#0b1020; --accent:#00ffd0; --danger:#ff4d6d; --gold:#ffd700; --silver:#c0c0c0; --bronze:#cd7f32; }
  html,body{
    height:100%; margin:0;
    background:linear-gradient(180deg,#010410 0%, #03081a 100%);
    font-family:'Segoe UI', Inter, Arial, sans-serif;
    color:#e8f7ff; overflow: hidden; touch-action: none; user-select: none;
  }
  #ui {
    width:100%; max-width:600px; margin:0 auto;
    display:flex; justify-content:space-between; align-items:center;
    padding:10px 15px; direction: ltr; position: absolute; top:0; left:0; right:0; z-index: 10;
    box-sizing: border-box;
  }
  #stats-area { display:flex; gap:8px; }
  .stat-box {
    background: rgba(0,0,0,0.3); padding:6px 10px;
    border-radius:8px; font-weight:600; color:#cfeff0; font-size: 13px;
    display:flex; align-items:center; border: 1px solid rgba(255,255,255,0.08);
    backdrop-filter: blur(2px);
  }
  #lives { display:flex; align-items:center; height: 20px; }
  #lives img { height:20px; width:auto; margin-right:2px; }
  #controls { display:flex; gap:8px; align-items:center; }
  button {
    background:var(--accent); color:#031018; border:none;
    padding:8px 16px; border-radius:6px; font-weight:700; cursor:pointer;
    font-size: 14px; transition: filter 0.2s;
  }
  button:active { filter: brightness(0.8); transform: scale(0.95); }
  button:disabled { background: #555; color: #888; cursor: not-allowed; transform: none; filter: none; }
  .btn-ghost{ background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); color:#e8f7ff;}
  .btn-secondary { background: #3b82f6; color: white; }
  canvas{
    display:block; margin: 0 auto;
    box-shadow:0 0 30px rgba(0,0,0,0.8);
    background-color: #000; 
    background-image: url('galaxy-bg.jpg'); 
    background-size: cover; background-position: center;
    touch-action: none;
  }
  #startOverlay, #gameOverOverlay, #lobbyOverlay {
    position:fixed; inset:0; z-index:50;
    display:flex; align-items:center; justify-content:center;
    background:rgba(2, 6, 23, 0.95); backdrop-filter: blur(8px);
    padding: 20px;
  }
  .panel{
    background:rgba(255,255,255,0.05); padding:25px;
    border-radius:24px; text-align:center; border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 20px 60px rgba(0,0,0,0.5); 
    width: 100%; max-width: 350px;
    animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    display: flex; flex-direction: column; gap: 10px;
  }
  @keyframes popIn { from{transform:scale(0.8);opacity:0;} to{transform:scale(1);opacity:1;} }
  .logo-img { max-width: 90%; height: auto; margin: 0 auto 5px auto; display: block; }
  h1 { margin: 0 0 5px 0; font-size: 26px; background: linear-gradient(to right, #fff, #00ffd0); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
  p { color: #94a3b8; margin-bottom: 15px; line-height: 1.5; font-size: 14px; }
  .full-btn { width: 100%; padding: 12px; font-size: 16px; border-radius: 10px; margin-top: 5px; }
  input[type="text"] {
    width: 100%; padding: 12px; border-radius: 10px; border: 1px solid #334155;
    background: #0f172a; color: white; box-sizing: border-box; margin-bottom: 10px; text-align: center;
  }
  .player-list { list-style: none; padding: 0; margin: 10px 0; max-height: 150px; overflow-y: auto; text-align: left; }
  .player-list li { background: rgba(255,255,255,0.1); padding: 8px; margin-bottom: 5px; border-radius: 6px; display: flex; justify-content: space-between; }
  .is-host { color: #ffd700; font-size: 12px; }
  .copy-box { background: #1e293b; padding: 8px; border-radius: 6px; font-family: monospace; font-size: 12px; cursor: pointer; word-break: break-all; margin-bottom: 10px;}
  
  .final-lb { width: 100%; margin-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; max-height: 200px; overflow-y: auto;}
  .final-lb-row { display: flex; justify-content: space-between; padding: 8px 5px; border-bottom: 1px solid rgba(255,255,255,0.05); align-items: center;}
  .rank-medal { font-size: 18px; margin-right: 5px; }
  .rank-text { color: #94a3b8; margin-right: 5px; font-weight: bold;}
  .player-status-dead { color: var(--danger); font-size: 11px; margin-left: 10px; }
  .player-status-alive { color: var(--accent); font-size: 11px; margin-left: 10px; }
</style>
</head>
<body>

<div id="ui">
  <div id="stats-area">
    <div class="stat-box" id="lives"></div>
    <div class="stat-box" id="scoreBox">0</div>
    <div class="stat-box" id="levelBox">Lvl 1</div>
  </div>
  <div id="controls">
    <button id="muteBtn" class="btn-ghost">ðŸ”‡</button>
  </div>
</div>

<canvas id="gameCanvas"></canvas>

<div id="startOverlay">
  <div class="panel">
    <img src="logo.png" alt="Game Logo" class="logo-img" onerror="this.style.display='none'">
    <h1>Stork Galaxy Shooter</h1>
    <p>Protect The Defi Galaxy!</p>
    <input type="text" id="playerNameInput" placeholder="Enter Your Nickname" maxlength="12">
    <button id="startSoloBtn" class="full-btn">Start Solo Game</button>
    <button id="startMultiBtn" class="full-btn btn-secondary">Play with Friends</button>
  </div>
</div>

<div id="lobbyOverlay" style="display:none">
  <div class="panel">
    <h2>Game Lobby</h2>
    <p>Send this link to your friends:</p>
    <div class="copy-box" id="shareLink" onclick="copyLink()">Generating Link...</div>
    <ul class="player-list" id="lobbyPlayerList"></ul>
    <div id="hostControls" style="display:none">
        <button id="hostStartBtn" class="full-btn" style="background:#00ffd0; color:#000;">Start Match</button>
    </div>
    <div id="clientStatus" style="display:none">
        <p>Waiting for host to start...</p>
    </div>
    <button onclick="leaveLobby()" class="btn-ghost" style="margin-top:10px; width:100%">Cancel / Leave</button>
  </div>
</div>

<div id="gameOverOverlay" style="display:none">
  <div class="panel">
    <h2 id="gameOverTitle" style="color:#ff4d6d; margin:0;">Mission Failed</h2>
    <p id="finalScoreText" style="font-size: 18px; color: #fff; margin-bottom: 10px;">Score: 0</p>
    <div id="multiplayerResults" style="display:none">
        <h3>Leaderboard</h3>
        <div class="final-lb" id="finalLeaderboard"></div>
    </div>
    <button id="mainMenuBtn" class="full-btn" style="margin-top: 15px;">Main Menu</button>
  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
  // UPDATED: Added 'get' to imports
  import { getDatabase, ref, set, push, onValue, update, remove, onDisconnect, get } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAwLl6q9dtuIm78mrCfR0dQRUy49WBNHTc",
    authDomain: "stork-galaxy-shooter.firebaseapp.com",
    databaseURL: "https://stork-galaxy-shooter-default-rtdb.firebaseio.com",
    projectId: "stork-galaxy-shooter",
    storageBucket: "stork-galaxy-shooter.firebasestorage.app",
    messagingSenderId: "516669330056",
    appId: "1:516669330056:web:a9c0e2c9a0c1e5cbeec53d",
    measurementId: "G-K8HY2GFBQ2"
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  
  window.db = db;
  window.dbRef = ref;
  window.dbSet = set;
  window.dbPush = push;
  window.dbOnValue = onValue;
  window.dbUpdate = update;
  window.dbRemove = remove;
  window.dbOnDisconnect = onDisconnect;
  window.dbGet = get; // UPDATED: Exposed get globally
</script>

<script>
const CONFIG = { lives: 5, eggIcon: 'egg.png' };

class SFX {
  constructor() { this.ctx = null; this.muted = false; }
  init(){ if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); }
  playShot(){ if(this.ctx && !this.muted) this.playTone(400, 200, 0.15, 'sine'); }
  playHit(){ if(this.ctx && !this.muted) this.playTone(100, 50, 0.2, 'sine'); }
  playExplode(){ if(this.ctx && !this.muted) this.playTone(80, 20, 0.5, 'triangle'); }
  playTone(f1, f2, dur, type){
    const t=this.ctx.currentTime, o=this.ctx.createOscillator(), g=this.ctx.createGain();
    o.type=type; o.frequency.setValueAtTime(f1, t); o.frequency.exponentialRampToValueAtTime(f2, t+dur);
    g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.001, t+dur);
    o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+dur);
  }
  toggleMute(){ this.muted = !this.muted; }
}
const sfx = new SFX();

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W, H, loopId = 0, lastTime = 0;
const state = {
  running: false, score: 0, level: 1,
  bullets: [], enemies: [], enemyBullets: [], particles: []
};
const player = { x:0, y:0, w:70, h:70, speed: 400, cooldown: 0, maxCooldown: 0.20, lives: CONFIG.lives, invul: 0 };
const inputs = { left: false, right: false };
const ASSETS = {};
['player.png','enemy1.png','enemy2.png','enemy3.png','enemy4.png','bullet.png','enemy_bullet.png'].forEach(s=>{
    const i=new Image(); i.src=s; i.onload=()=>ASSETS[s]=i;
});

let isMultiplayer = false;
let roomId = null;
let playerId = null;
let playerName = "Player";
let isHost = false;
let joiningInProgress = false; 

const urlParams = new URLSearchParams(window.location.search);
if(urlParams.get('room')){
    roomId = urlParams.get('room');
    document.getElementById('startSoloBtn').style.display = 'none';
    document.getElementById('startMultiBtn').innerText = 'Join Lobby';
}

function resize(){
  W = window.innerWidth; H = window.innerHeight;
  if(W>600){ W=600; canvas.style.margin="0 auto"; } else { canvas.style.margin="0"; }
  canvas.width=W*window.devicePixelRatio; canvas.height=H*window.devicePixelRatio;
  canvas.style.width=W+'px'; canvas.style.height=H+'px';
  ctx.scale(window.devicePixelRatio,window.devicePixelRatio);
}
window.addEventListener('resize', resize); resize();

function update(dt){
  if(!state.running) return;

  if(player.invul>0) player.invul-=dt;
  let dx=0; if(inputs.left) dx=-1; if(inputs.right) dx=1;
  player.x += dx * player.speed * dt;
  player.x = Math.max(0, Math.min(W - player.w, player.x));

  player.cooldown -= dt;
  if(player.cooldown <= 0){
    const weapon = {count: Math.min(5, Math.ceil(state.level/2)), spread: state.level*2, speed: 500+(state.level*50)};
    player.cooldown = player.maxCooldown;
    const center = player.x + player.w/2;
    const startAngle = -90 - ((weapon.count-1)*weapon.spread)/2;
    for(let i=0; i<weapon.count; i++){
      const ang = (startAngle + i*weapon.spread) * Math.PI/180;
      state.bullets.push({x: center-25, y: player.y, w:50, h:80, vx:Math.cos(ang)*weapon.speed, vy:Math.sin(ang)*weapon.speed});
    }
    sfx.playShot();
  }

  state.bullets.forEach((b,i) => {
    b.x+=b.vx*dt; b.y+=b.vy*dt;
    if(b.y<-50 || b.x<-50 || b.x>W+50) state.bullets.splice(i,1);
  });

  state.enemies.forEach((e,i) => {
    e.y+=e.speed*dt;
    
    e.reload-=dt;
    if(e.reload<=0 && ['basic','tank'].includes(e.type)){
        if(Math.random()<0.4) state.enemyBullets.push({x:e.x+e.w/2-25, y:e.y+e.h, w:50, h:70, vx:0, vy:180});
        e.reload = 2+Math.random();
    }

    const bIdx = state.bullets.findIndex(b => b.x < e.x+e.w && b.x+b.w > e.x && b.y < e.y+e.h && b.y+b.h > e.y);
    if(bIdx !== -1){
      state.bullets.splice(bIdx,1); e.hp--; sfx.playHit();
      if(e.hp<=0){
        state.score += (e.type==='tank'?20:10);
        state.enemies.splice(i,1);
        spawnParticles(e.x+e.w/2, e.y+e.h/2, '#ffaa00');
        sfx.playExplode();
        if(isMultiplayer && window.dbUpdate) syncScore();
      }
      return;
    }

    if(player.invul<=0 && player.x < e.x+e.w-10 && player.x+player.w > e.x+10 && player.y < e.y+e.h-10 && player.y+player.h > e.y+10){
       hitPlayer(); state.enemies.splice(i,1);
    }
    if(e.y>H){ state.enemies.splice(i,1); hitPlayer(); }
  });

  state.enemyBullets.forEach((b,i) => {
    b.y+=b.vy*dt;
    if(player.invul<=0 && b.x < player.x+player.w && b.x+b.w > player.x && b.y < player.y+player.h && b.y+b.h > player.y){
       hitPlayer(); state.enemyBullets.splice(i,1);
    }
    if(b.y>H) state.enemyBullets.splice(i,1);
  });

  state.particles.forEach((p,i) => {
    p.life-=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; if(p.life<=0) state.particles.splice(i,1);
  });

  if(state.enemies.length < 3 + Math.floor(state.level/2)) spawnEnemy();
  if(state.score >= 300 + Math.floor(Math.pow(state.level, 2) * 25)){ state.level++; sfx.playExplode(); }

  document.getElementById('scoreBox').innerText = ` ${state.score}`;
  document.getElementById('levelBox').innerText = `Lvl ${state.level}`;
}

function spawnEnemy(){
  const r=Math.random();
  let type='basic', hp=1, size=45;
  if(state.level>2 && r>0.7) { type='tank'; size=55; hp=3+Math.floor(state.level/3); }
  else if(state.level>4 && r>0.85) type='fast';
  else if(state.level>1 && r>0.5 && r<0.7) type='passive1';
  else if(state.level>3 && r>0.4 && r<0.5) { type='passive2'; hp=2; }
  
  state.enemies.push({
    x: Math.random()*(W-size), y:-60, w:size, h:size, type, hp,
    speed: (Math.random()*50+50)*(1+state.level*0.02), reload: Math.random()*2
  });
}

function hitPlayer(){
  player.lives--;
  if(player.lives < 0) player.lives = 0;
  
  player.invul=2.0; 
  updateLivesUI(); 
  sfx.playHit(); 
  spawnParticles(player.x+player.w/2, player.y+player.h/2, '#00ffd0');
  
  if(player.lives<=0) {
      gameOver();
  }
}

function spawnParticles(x,y,c){
  for(let i=0;i<8;i++){
    const a=Math.random()*6.28, s=Math.random()*100;
    state.particles.push({x, y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:0.5, color:c});
  }
}

function draw(){
  ctx.clearRect(0,0,W,H);
  const t=Date.now()/1000;
  ctx.fillStyle='#fff';
  for(let i=0;i<50;i++){
    const x=(i*137)%W, y=(i*223+t*100)%H;
    ctx.globalAlpha=(Math.sin(t+i)+1)*0.25; ctx.fillRect(x,y,2,2);
  }
  ctx.globalAlpha=1;

  if(player.invul<=0 || Math.floor(Date.now()/100)%2){
    if(ASSETS['player.png']) ctx.drawImage(ASSETS['player.png'], player.x, player.y, player.w, player.h);
    else { ctx.fillStyle='#00ffd0'; ctx.fillRect(player.x, player.y, player.w, player.h); }
  }

  state.enemies.forEach(e => {
    let img = ASSETS['enemy1.png'];
    if(e.type==='tank') img=ASSETS['enemy2.png']; else if(e.type==='passive1') img=ASSETS['enemy3.png']; else if(e.type==='passive2') img=ASSETS['enemy4.png'];
    if(img) ctx.drawImage(img, e.x, e.y, e.w, e.h); else { ctx.fillStyle='#ff4d6d'; ctx.fillRect(e.x,e.y,e.w,e.h); }
  });
  state.bullets.forEach(b => { if(ASSETS['bullet.png']) ctx.drawImage(ASSETS['bullet.png'], b.x, b.y, b.w, b.h); else { ctx.fillStyle='#ffeb3b'; ctx.fillRect(b.x, b.y, b.w, b.h); }});
  state.enemyBullets.forEach(b => { if(ASSETS['enemy_bullet.png']) ctx.drawImage(ASSETS['enemy_bullet.png'], b.x, b.y, b.w, b.h); else { ctx.fillStyle='#ff4d6d'; ctx.fillRect(b.x, b.y, b.w, b.h); }});
  state.particles.forEach(p => { ctx.globalAlpha=p.life*2; ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,4,4); });
  ctx.globalAlpha=1;
}

function loop(ts){
  if(!state.running) return;
  const dt = Math.min((ts-lastTime)/1000, 0.1); lastTime=ts;
  update(dt); draw();
  loopId = requestAnimationFrame(loop);
}

function initGame(){
  sfx.init();
  cancelAnimationFrame(loopId);
  state.running = false;
  
  document.getElementById('startOverlay').style.display = 'none';
  document.getElementById('lobbyOverlay').style.display = 'none';
  document.getElementById('gameOverOverlay').style.display = 'none';
  
  state.score=0; state.level=1; state.bullets=[]; state.enemies=[]; state.enemyBullets=[]; state.particles=[];
  player.lives = CONFIG.lives; player.x = W/2 - player.w/2; player.y = H - player.h - 20;
  
  updateLivesUI();
  
  state.running = true;
  lastTime = performance.now();
  loopId = requestAnimationFrame(loop);
}

function gameOver(){
  state.running = false;
  cancelAnimationFrame(loopId); 
  
  document.getElementById('finalScoreText').innerText = `Score: ${state.score}`;
  document.getElementById('gameOverOverlay').style.display = 'flex';
  
  if(isMultiplayer){
      document.getElementById('gameOverTitle').innerText = "Game Ended";

      window.dbUpdate(window.dbRef(window.db, `rooms/${roomId}/players/${playerId}`), {
          score: state.score,
          isDead: true
      });
      document.getElementById('multiplayerResults').style.display = 'block';
      fetchLeaderboard();
  } else {
      document.getElementById('gameOverTitle').innerText = "Mission Failed";
      document.getElementById('multiplayerResults').style.display = 'none';
  }
}

function updateLivesUI(){
  const div = document.getElementById('lives'); 
  div.innerHTML = '';
  for(let i=0;i<CONFIG.lives;i++){
    const img=document.createElement('img'); img.src=CONFIG.eggIcon;
    if(i>=player.lives) img.style.opacity='0.2'; 
    div.appendChild(img);
  }
}

function getPlayerName(){
    const input = document.getElementById('playerNameInput');
    let name = input.value.trim();
    if(!name) name = "Stork_" + Math.floor(Math.random()*1000);
    return name;
}

async function createLobby(){
    if(joiningInProgress) return;
    joiningInProgress = true;
    
    const btn = document.getElementById('startMultiBtn');
    if(btn) { btn.disabled = true; btn.innerText = "Creating..."; }

    if(!window.db) { alert("Connecting to server... please wait"); joiningInProgress = false; if(btn) {btn.disabled=false; btn.innerText="Play with Friends";} return; }
    
    playerName = getPlayerName();
    playerId = 'host_' + Date.now();
    roomId = 'room_' + Math.floor(Math.random()*10000);
    isHost = true;
    isMultiplayer = true;

    const roomRef = window.dbRef(window.db, `rooms/${roomId}`);
    await window.dbSet(roomRef, {
        status: 'lobby',
        players: {
            [playerId]: { name: playerName, score: 0, isHost: true, isDead: false }
        }
    });
    
    showLobbyUI();
    listenToLobby();
    joiningInProgress = false;
}

// UPDATED: Function now checks for duplicates before joining
async function joinLobby(){
    if(joiningInProgress) return;
    joiningInProgress = true;

    const btn = document.getElementById('startMultiBtn');
    if(btn) { btn.disabled = true; btn.innerText = "Joining..."; }

    if(!window.db) { 
        alert("Connecting to server... please wait"); 
        joiningInProgress = false; 
        if(btn) {btn.disabled=false; btn.innerText="Join Lobby";} 
        return; 
    }
    if(!roomId) return;
    
    playerName = getPlayerName();

    // --- Check Duplicate Name Logic ---
    try {
        const roomPlayersRef = window.dbRef(window.db, `rooms/${roomId}/players`);
        const snapshot = await window.dbGet(roomPlayersRef);

        if (snapshot.exists()) {
            const players = snapshot.val();
            const isNameTaken = Object.values(players).some(p => p.name.toLowerCase() === playerName.toLowerCase());

            if (isNameTaken) {
                alert("This username has already been used in this game! Please choose another name.");
                
                joiningInProgress = false;
                if(btn) { btn.disabled = false; btn.innerText = "Join Lobby"; }
                return; // Exit logic
            }
        }
    } catch (error) {
        console.error("Error checking names:", error);
    }
    // --- End Logic ---

    playerId = 'p_' + Date.now();
    isHost = false;
    isMultiplayer = true;

    const playerRef = window.dbRef(window.db, `rooms/${roomId}/players/${playerId}`);
    await window.dbSet(playerRef, {
        name: playerName,
        score: 0,
        isHost: false,
        isDead: false
    });
    
    showLobbyUI();
    listenToLobby();
    joiningInProgress = false;
}

function showLobbyUI(){
    document.getElementById('startOverlay').style.display = 'none';
    document.getElementById('lobbyOverlay').style.display = 'flex';
    document.getElementById('shareLink').innerText = window.location.origin + window.location.pathname + '?room=' + roomId;
    
    if(isHost){
        document.getElementById('hostControls').style.display = 'block';
        document.getElementById('clientStatus').style.display = 'none';
    } else {
        document.getElementById('hostControls').style.display = 'none';
        document.getElementById('clientStatus').style.display = 'block';
    }
}

function listenToLobby(){
    const roomRef = window.dbRef(window.db, `rooms/${roomId}`);
    window.dbOnValue(roomRef, (snapshot) => {
        const data = snapshot.val();
        if(!data) {
            alert("Room closed by host");
            location.href = window.location.pathname;
            return;
        }
        const list = document.getElementById('lobbyPlayerList');
        list.innerHTML = '';
        if(data.players){
            Object.values(data.players).forEach(p => {
                const li = document.createElement('li');
                li.innerHTML = `<span>${p.name}</span> ${p.isHost ? '<span class="is-host">HOST</span>' : ''}`;
                list.appendChild(li);
            });
        }
        if(data.status === 'playing' && !state.running && player.lives > 0){
            initGame();
        }
    });
}

function startMultiplayerGame(){
    if(!isHost) return;
    window.dbUpdate(window.dbRef(window.db, `rooms/${roomId}`), { status: 'playing' });
}

function syncScore(){
    if(!isMultiplayer || !roomId || !playerId) return;
    window.dbUpdate(window.dbRef(window.db, `rooms/${roomId}/players/${playerId}`), { score: state.score });
}

function fetchLeaderboard(){
    const playersRef = window.dbRef(window.db, `rooms/${roomId}/players`);
    window.dbOnValue(playersRef, (snapshot) => {
        const players = snapshot.val();
        const lb = document.getElementById('finalLeaderboard');
        lb.innerHTML = '';
        if(!players) return;
        
        const sorted = Object.values(players).sort((a,b) => b.score - a.score);
        
        sorted.forEach((p, index) => {
            const div = document.createElement('div');
            div.className = 'final-lb-row';
            
            let rankDisplay = '';
            if(index === 0) rankDisplay = '<span class="rank-medal">ðŸ¥‡</span>';
            else if(index === 1) rankDisplay = '<span class="rank-medal">ðŸ¥ˆ</span>';
            else if(index === 2) rankDisplay = '<span class="rank-medal">ðŸ¥‰</span>';
            else rankDisplay = `<span class="rank-text">#${index+1}</span>`;

            let statusText = '';
            if (p.isDead) {
                statusText = '<span class="player-status-dead">(âœ… Final Score)</span>';
            } else {
                statusText = '<span class="player-status-alive">(Playing...)</span>';
            }
            
            div.innerHTML = `
                <div style="display:flex; align-items:center;">
                    ${rankDisplay} 
                    <span>${p.name}</span>
                    ${statusText} 
                </div>
                <span style="color:#00ffd0; font-weight:bold;">${p.score}</span>
            `;
            lb.appendChild(div);
        });
    });
}

window.copyLink = function(){
    const link = document.getElementById('shareLink').innerText;
    navigator.clipboard.writeText(link).then(() => alert("Link copied!"));
}

window.leaveLobby = function(){
    if(isHost && roomId && window.db){
        if(!state.running) window.dbRemove(window.dbRef(window.db, `rooms/${roomId}`));
    }
    location.href = window.location.pathname;
}

document.getElementById('startSoloBtn').onclick = () => { isMultiplayer=false; initGame(); };
document.getElementById('startMultiBtn').onclick = () => {
    if(joiningInProgress) return;
    if(roomId) joinLobby();
    else createLobby();
};
document.getElementById('hostStartBtn').onclick = startMultiplayerGame;

document.getElementById('mainMenuBtn').onclick = () => {
    if(isHost && roomId && window.db){
    }
    location.href = window.location.pathname;
};

let dragOffset = 0, isDragging = false;
canvas.addEventListener('pointerdown', e => {
  e.preventDefault(); isDragging = true; sfx.init();
  const rect = canvas.getBoundingClientRect();
  const touchX = (e.clientX - rect.left) * (canvas.width / rect.width) / window.devicePixelRatio;
  dragOffset = touchX - player.x;
});
canvas.addEventListener('pointermove', e => {
  if (!isDragging) return; e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const touchX = (e.clientX - rect.left) * (canvas.width / rect.width) / window.devicePixelRatio;
  player.x = Math.max(0, Math.min(W - player.w, touchX - dragOffset));
});
canvas.addEventListener('pointerup', () => isDragging = false);
canvas.addEventListener('pointercancel', () => isDragging = false);
window.addEventListener('keydown', e => { if(e.key==='ArrowLeft') inputs.left=true; if(e.key==='ArrowRight') inputs.right=true; });
window.addEventListener('keyup', e => { if(e.key==='ArrowLeft') inputs.left=false; if(e.key==='ArrowRight') inputs.right=false; });
document.getElementById('muteBtn').onclick = () => { sfx.toggleMute(); document.getElementById('muteBtn').innerText=sfx.muted?'ðŸ”‡':'ðŸ”Š'; };
updateLivesUI();
</script>
</body>
</html>
